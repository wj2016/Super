* jq
#+BEGIN_SRC sh
brew install jq
echo '{"age":18, "name":"Jia"}' | jq "."

cd ~/Super
## sample json file
mkdir sample_files
cd sample_files
curl -v http://bookapi.bignerdranch.com/courses.json > bnr_courses.json
cat bnr_courses.json | jq ".courses"
cat bnr_courses.json | jq ".courses[0]"
cat bnr_courses.json | jq ".courses[0].title"
#+END_SRC

* curl
#+BEGIN_SRC sh
curl google.com

## -L redirect
curl -L google.com

## -v
curl -v ifconfig.me
curl -v ifconfig.me/all.json | jq "."

## -H add headers
curl -v ifconfig.me/all.json -H "Accept-charset: utf-8"
#+END_SRC

* resty

* Charles

* Linux Commands
#+BEGIN_SRC sh
netstat -tnl

## 32-bit or 64-bit ubuntu
uname -a

#+END_SRC

* Mac Commands
#+BEGIN_SRC sh
## show PID listening on a specific port
lsof -n -i4TCP:8080 | grep LISTEN

## listen on a port
nc -l 1234
#+END_SRC


* Vagrant VMs
VM and IP address table
| VM          |             IP |
|-------------+----------------|
| Ubuntu14.04 | 192.168.55.100 |
| PostgreSQL  | 192.168.88.101 |
| ErlangDev1  | 192.168.99.111 |
| ErlangDev2  | 192.168.99.112 |
|             |                |
** Erlang nodes
#+BEGIN_SRC sh
cd ~/Super/VMs/ErlangDev1
vagrant up
vagrant ssh

cd ~/Super/VMs/ErlangDev2
vagrant up
vagrant ssh

ping dev1.wangjia.com -c 4
ping dev2.wangjia.com -c 4

erl -name dev111 -setcookie abc
erl -name dev222 -setcookie abc
net_adm:ping('dev111@dev1.wangjia.com').
nodes().
#+END_SRC
** Basic Workflow - Demo with default Ubuntu 14.04
#+BEGIN_SRC sh
cd ~/Super/VMs/Ubuntu14.04

## Start VM
vagrant up

## Ping to verify it's running
ping 192.168.33.10

## Connect to VM
vagrant ssh

## new command
tree
sudo apt-get install tree
tree

## Disconnect
exit

## Stop VM
vagrant halt

## Destroy VM
vagrant destroy
y
#+END_SRC
** Stop all running VMs
#+BEGIN_SRC sh
VBoxManage list runningvms
vagrant global-status
vagrant global-status | grep virtualbox | cut -c 1-9 | while read line; do echo $line; vagrant halt $line; done;
#+END_SRC
* PostgreSQL
** Install PostgreSQL on Ubuntu 14.04
#+BEGIN_SRC sh
cd ~/Super/VMs/PostgreSQL
vagrant up
vagrant ssh
wget http://ftp.postgresql.org/pub/source/v9.3.2/postgresql-9.3.2.tar.bz2
tar xvfj postgresql-9.3.2.tar.bz2
cd postgresql-9.3.2
mkdir -p ${HOME}/Apps/postgresql-9.3.2
ls ${HOME}/Apps/postgresql-9.3.2
sudo apt-get install libreadline-dev
./configure --prefix=${HOME}/Apps/postgresql-9.3.2
make; make install
ls ${HOME}/Apps/postgresql-9.3.2/bin

## add bin to path
echo 'export PATH=${HOME}/Apps/postgresql-9.3.2/bin:${PATH}' >> ~/.bashrc
which postgres

#+END_SRC
** Initialize PostgresSQL
#+BEGIN_SRC sh
## Setup SQL Data directory
export PGDATA=~/postgresql_data/
rm    -rf  ${PGDATA}
mkdir  -p  ${PGDATA}
ls         ${PGDATA}
initdb -D  ${PGDATA}
ls ${PGDATA}
#+END_SRC

#+BEGIN_SRC sh
export POSTGRESQL_LOG_DIR=~/postgresql_log/
rm -rf ${POSTGRESQL_LOG_DIR}
mkdir -p ${POSTGRESQL_LOG_DIR}
ls ${POSTGRESQL_LOG_DIR}

#+END_SRC

** Change config
*** postgresql.conf
emacs ${PGDATA}/postgresql.conf
listen_addresses = '*'
max_connections = 224
*** pg_hba.conf
emacs ${PGDATA}/pg_hba.conf
host   all   all   192.168.88.1/32   trust

** Start PostgresSQL
#+begin_src sh
export PGDATA=~/postgresql_data/
export POSTGRESQL_LOG_DIR=~/postgresql_log/
ls ${PGDATA}
ls ${POSTGRESQL_LOG_DIR}
pg_ctl -D ${PGDATA} -l ${POSTGRESQL_LOG_DIR}/mylog start
pg_ctl status
#+end_src

** Stop PostgresSQL
#+begin_src sh
pg_ctl stop
#+end_src

** Create first DB with createdb in PostgreSQL
#+begin_src sh
createuser --host=localhost --superuser wangjia
createdb --host=localhost my_db --owner wangjia
psql --host=localhost --list
#+end_src

** Use PostgreSQL
*** Local access
#+begin_src sh
## connect to LOCAL PostgreSQL
psql --host=localhost --dbname=my_db
\q
#+end_src

*** Remote access
Run on Mac OS X with pgAdmin3
#+begin_src sh
/Applications/pgAdmin3.app/Contents/SharedSupport/psql \
     --username=wangjia --host=192.168.88.101 --dbname=my_db
psql --username=wangjia --host=192.168.88.101 --dbname=my_db
#+end_src

** Demo PostgreSQL
#+begin_src sql
-- list all tables in PostgreSQL
SELECT * FROM pg_tables;

-- create demo_table
CREATE TABLE demo_table (demo_column int, another int);

-- find all tables
SELECT table_name, table_schema
FROM information_schema.tables
WHERE table_schema = 'public';

-- select
SELECT * FROM demo_table;

-- insert some data
INSERT INTO demo_table VALUES (555, 777);
INSERT INTO demo_table VALUES (888, 666);

-- query again
SELECT * FROM demo_table;
#+end_src

** Demo PostgreSQL Erlang Client
#+begin_src sh
## build PostgreSQL Erlang Client
cd ~/Erlang/PostgreSQL
git clone https://github.com/wg/epgsql.git
cd epgsql
make
cd ..
#+end_src

verify library

#+begin_src sh
erl -pa epgsql/ebin
%% Connect to a non-exisintg DB
pgsql:connect("127.0.0.1", "wangjia", "", [{database, "non_existing_db"}]).

%% Connect to an existing DB
{ok, Conn} = pgsql:connect("192.168.88.101", "wangjia", "", [{database, "my_db"}]).
q().

cd ~/Erlang/PostgreSQL
erl -pa epgsql/ebin
c(demo_client).
demo_client:default_connection().
f(), C = v(-1), pgsql:close(C).
demo_client:demo_other_host_connection().
f(), C = v(-1), pgsql:close(C).

%% Demo how to use Erlang-PostgreSQL client interact with PostgreSQL
demo_client:demo_simple_connection().
demo_client:demo_get_table_spec().
q().
#+end_src
* AWS
** EC2 basics
#+BEGIN_SRC sh
## connect
ssh -i ${AWS_FILE} ${AWS_HOST}

## copy files
scp -i ${AWS_FILE} hello.txt ${AWS_HOST}:/home/ubuntu
#+END_SRC

** Check memory
free -m

Today, on my micro EC2 it looks like:
#+BEGIN_QUOTE
free -m
             total       used       free     shared    buffers     cached
Mem:           992        744        247          0        149        478
-/+ buffers/cache:        116        875
Swap:            0          0          0
#+END_QUOTE
http://www.linuxatemyram.com/

How do I see how much free ram I really have?
(free/buffers/cache) => 875

** Install software for an Erlang environment
sudo apt-get update
sudo apt-get install erlang-base tree emacs make

** Change timezone on Ubuntu
#+BEGIN_SRC sh
date
sudo timedatectl list-timezones | grep CET
sudo timedatectl list-timezones | grep Stockholm
Europe/Stockholm
sudo timedatectl set-timezone Europe/Stockholm
#+END_SRC
internally, it did
ln -sf /usr/share/zoneinfo/Europe/Stockholm /etc/localtime

** Change hostname on Ubuntu
#+BEGIN_SRC sh
sudo emacs /etc/hostname
erlang-dev-server

sudo emacs /etc/hosts
127.0.1.1 erlang-dev-server
sudo hostname erlang-dev-server
#+END_SRC
** EBS Volume
*** 0, Current Settings:
#+BEGIN_SRC sh
sudo lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL
#+END_SRC
NAME    FSTYPE SIZE MOUNTPOINT LABEL
xvda             8G
└─xvda1 ext4     8G /          cloudimg-rootfs

Check current mount
df

*** 1, Check EC2 zone
EC2 Zone -> eu-central-1a

*** 2, Create Volume

*** 3, Attach Volume
Select the Volume just created and 'Action' -> Attach Volume

*** 4, Check disks with lsblk and dmesg
sudo lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL
dmesg
"xvdf: unknown partition table"

*** 5, use fdisk to create partition
#+BEGIN_SRC sh
sudo fdisk /dev/xvdf
m        ## help
p        ## print
n        ## add new partition
p        ## primary
1        ## 1 partition followed with default first sector and last sector


p        ## print partition again to check
w        ## write the partition
#+END_SRC

#+BEGIN_QUOTE
sudo lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL
NAME    FSTYPE SIZE MOUNTPOINT LABEL
xvda             8G
└─xvda1 ext4     8G /          cloudimg-rootfs
xvdf             2G
└─xvdf1          2G
#+END_QUOTE

*** 6, Use mkfs to create file system on partition
#+BEGIN_SRC sh
sudo mkfs -t ext4 /dev/xvdf1
#+END_SRC

*** 7, mount to use it
#+BEGIN_SRC sh
sudo mkdir /data

## Check current mount
df

## mount new disk
sudo mount /dev/xvdf1 /data
df -h
#+END_SRC

*** 8, Add mount to fstab to make it available after reboot
#+BEGIN_SRC sh
sudo emacs /etc/fstab
/dev/xvdf1	/data	ext4	defaults,nofail,nobootwait	0	0

## Dangerous way, if mount fails, I can't ssh to the intance anymore.
/dev/xvdf1	/data	ext4	defaults	0	0

#+END_SRC

*** 9, write some data to new disk to test it
chown ubuntu:ubuntu /data
echo "hello, world" > /data/hello.txt

* Git
#+BEGIN_SRC sh
## Only show first line in commit comments
git log --pretty=oneline --abbrev-commit

#+END_SRC
